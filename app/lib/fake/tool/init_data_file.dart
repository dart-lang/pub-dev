// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:convert';
import 'dart:io';

import 'package:_pub_shared/data/task_payload.dart';
import 'package:_pub_shared/worker/docker_utils.dart';
import 'package:args/command_runner.dart';
import 'package:gcloud/service_scope.dart';
import 'package:logging/logging.dart';
import 'package:path/path.dart' as p;
import 'package:pub_dev/fake/backend/fake_pub_worker.dart';

import 'package:pub_dev/frontend/static_files.dart';
import 'package:pub_dev/service/services.dart';
import 'package:pub_dev/task/backend.dart';
import 'package:pub_dev/tool/test_profile/import_source.dart';
import 'package:pub_dev/tool/test_profile/importer.dart';
import 'package:pub_dev/tool/test_profile/models.dart';

import '../server/local_server_state.dart';

/// Initialize fake server's local data.
class FakeInitDataFileCommand extends Command {
  @override
  String get description => 'Initialize local data fro fake server.';

  @override
  String get name => 'init-data-file';

  FakeInitDataFileCommand() {
    argParser
      ..addOption('test-profile',
          help: 'The file to read the test profile from.')
      ..addOption(
        'source',
        allowed: ['pub.dev', 'fake'],
        help: 'Download package content from pub.dev or create fake sources.',
        defaultsTo: 'pub.dev',
      )
      ..addOption(
        'analysis',
        allowed: ['none', 'fake', 'local', 'worker'],
        help:
            'Analyze the package with fake, local or dockerized worker analysis.',
        defaultsTo: 'none',
      )
      ..addOption('data-file', help: 'The file to store the local state.');
  }

  @override
  Future<void> run() async {
    Logger.root.onRecord.listen((r) {
      print([
        r.time.toIso8601String(),
        r.toString(),
        r.error,
        r.stackTrace?.toString(),
      ].nonNulls.join(' '));
    });

    final analysis = argResults!['analysis'] as String;
    final source = argResults!['source'] as String;
    final dataFile = argResults!['data-file'] as String;
    final profile = TestProfile.fromYaml(
      await File(argResults!['test-profile'] as String).readAsString(),
    );
    await updateLocalBuiltFilesIfNeeded();

    final archiveCachePath = p.join(
      resolveAppDir(),
      '.dart_tool',
      'pub-test-profile',
      'archives',
    );

    final state = LocalServerState();

    await withFakeServices(
        datastore: state.datastore,
        storage: state.storage,
        fn: () async {
          // ignore: invalid_use_of_visible_for_testing_member
          await importProfile(
            profile: profile,
            source: source == 'pub.dev'
                ? ImportSource.fromPubDev(archiveCachePath: archiveCachePath)
                : ImportSource.autoGenerated(),
          );

          if (analysis == 'local') {
            await _analyzeLocal();
          } else if (analysis == 'worker') {
            await _analyzeWorker();
          } else if (analysis == 'fake') {
            await processTasksWithFakePanaAndDartdoc();
          }
        });
    await state.save(dataFile);
  }
}

Future<void> _analyzeLocal() async {
  await fork(() async {
    await taskBackend.backfillAndProcessAllPackages((Payload payload) async {
      final arguments = [json.encode(payload.toJson())];
      final pr = await Process.run(
        Platform.resolvedExecutable,
        ['run', 'pub_worker', ...arguments],
        workingDirectory: p.join(resolveAppDir(), '..', 'pkg', 'pub_worker'),
      );
      if (pr.exitCode != 0) {
        throw Exception('Unexpected status code: ${pr.exitCode} ${pr.stdout}');
      }
    });
  });
}

Future<void> _analyzeWorker() async {
  await buildDockerImage();
  await fork(() async {
    await taskBackend.backfillAndProcessAllPackages((Payload payload) async {
      final p = await startDockerAnalysis(payload);
      final exitCode = await p.exitCode;
      if (exitCode != 0) {
        throw Exception(
            'Failed to analyze ${payload.package} with exitCode $exitCode');
      }
    });
  });
}
